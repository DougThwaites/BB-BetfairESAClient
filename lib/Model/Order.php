<?php
/**
 * Order
 *
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   http://github.com/swagger-api/swagger-codegen
 * @license  http://www.apache.org/licenses/LICENSE-2.0 Apache Licene v2
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Betfair: Exchange Streaming API
 *
 * API to receive streamed updates. This is an ssl socket connection of CRLF delimited json messages (see RequestMessage & ResponseMessage)
 *
 * OpenAPI spec version: 1.0.1423
 * Contact: bdp@betfair.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Model;

use \ArrayAccess;

/**
 * Order Class Doc Comment
 *
 * @category    Class */
/** 
 * @package     Swagger\Client
 * @author      http://github.com/swagger-api/swagger-codegen
 * @license     http://www.apache.org/licenses/LICENSE-2.0 Apache Licene v2
 * @link        https://github.com/swagger-api/swagger-codegen
 */
class Order implements ArrayAccess
{
    /**
      * The original name of the model.
      * @var string
      */
    protected static $swaggerModelName = 'Order';

    /**
      * Array of property to type mappings. Used for (de)serialization
      * @var string[]
      */
    protected static $swaggerTypes = array(
        'side' => 'string',
        'sv' => 'double',
        'pt' => 'string',
        'ot' => 'string',
        'p' => 'double',
        'sc' => 'double',
        'rc' => 'string',
        's' => 'double',
        'pd' => 'int',
        'rac' => 'string',
        'md' => 'int',
        'sl' => 'double',
        'avp' => 'double',
        'sm' => 'double',
        'id' => 'string',
        'bsp' => 'double',
        'status' => 'string',
        'sr' => 'double'
    );

    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of attributes where the key is the local name, and the value is the original name
     * @var string[]
     */
    protected static $attributeMap = array(
        'side' => 'side',
        'sv' => 'sv',
        'pt' => 'pt',
        'ot' => 'ot',
        'p' => 'p',
        'sc' => 'sc',
        'rc' => 'rc',
        's' => 's',
        'pd' => 'pd',
        'rac' => 'rac',
        'md' => 'md',
        'sl' => 'sl',
        'avp' => 'avp',
        'sm' => 'sm',
        'id' => 'id',
        'bsp' => 'bsp',
        'status' => 'status',
        'sr' => 'sr'
    );

    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     * @var string[]
     */
    protected static $setters = array(
        'side' => 'setSide',
        'sv' => 'setSv',
        'pt' => 'setPt',
        'ot' => 'setOt',
        'p' => 'setP',
        'sc' => 'setSc',
        'rc' => 'setRc',
        's' => 'setS',
        'pd' => 'setPd',
        'rac' => 'setRac',
        'md' => 'setMd',
        'sl' => 'setSl',
        'avp' => 'setAvp',
        'sm' => 'setSm',
        'id' => 'setId',
        'bsp' => 'setBsp',
        'status' => 'setStatus',
        'sr' => 'setSr'
    );

    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     * @var string[]
     */
    protected static $getters = array(
        'side' => 'getSide',
        'sv' => 'getSv',
        'pt' => 'getPt',
        'ot' => 'getOt',
        'p' => 'getP',
        'sc' => 'getSc',
        'rc' => 'getRc',
        's' => 'getS',
        'pd' => 'getPd',
        'rac' => 'getRac',
        'md' => 'getMd',
        'sl' => 'getSl',
        'avp' => 'getAvp',
        'sm' => 'getSm',
        'id' => 'getId',
        'bsp' => 'getBsp',
        'status' => 'getStatus',
        'sr' => 'getSr'
    );

    public static function getters()
    {
        return self::$getters;
    }

    const SIDE_B = 'B';
    const SIDE_L = 'L';
    const PT_L = 'L';
    const PT_P = 'P';
    const PT_MOC = 'MOC';
    const OT_L = 'L';
    const OT_LOC = 'LOC';
    const OT_MOC = 'MOC';
    const STATUS_E = 'E';
    const STATUS_EC = 'EC';
    

    
    /**
     * Gets allowable values of the enum
     * @return string[]
     */
    public function getSideAllowableValues()
    {
        return [
            self::SIDE_B,
            self::SIDE_L,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     * @return string[]
     */
    public function getPtAllowableValues()
    {
        return [
            self::PT_L,
            self::PT_P,
            self::PT_MOC,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     * @return string[]
     */
    public function getOtAllowableValues()
    {
        return [
            self::OT_L,
            self::OT_LOC,
            self::OT_MOC,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     * @return string[]
     */
    public function getStatusAllowableValues()
    {
        return [
            self::STATUS_E,
            self::STATUS_EC,
        ];
    }
    

    /**
     * Associative array for storing property values
     * @var mixed[]
     */
    protected $container = array();

    /**
     * Constructor
     * @param mixed[] $data Associated array of property value initalizing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['side'] = isset($data['side']) ? $data['side'] : null;
        $this->container['sv'] = isset($data['sv']) ? $data['sv'] : null;
        $this->container['pt'] = isset($data['pt']) ? $data['pt'] : null;
        $this->container['ot'] = isset($data['ot']) ? $data['ot'] : null;
        $this->container['p'] = isset($data['p']) ? $data['p'] : null;
        $this->container['sc'] = isset($data['sc']) ? $data['sc'] : null;
        $this->container['rc'] = isset($data['rc']) ? $data['rc'] : null;
        $this->container['s'] = isset($data['s']) ? $data['s'] : null;
        $this->container['pd'] = isset($data['pd']) ? $data['pd'] : null;
        $this->container['rac'] = isset($data['rac']) ? $data['rac'] : null;
        $this->container['md'] = isset($data['md']) ? $data['md'] : null;
        $this->container['sl'] = isset($data['sl']) ? $data['sl'] : null;
        $this->container['avp'] = isset($data['avp']) ? $data['avp'] : null;
        $this->container['sm'] = isset($data['sm']) ? $data['sm'] : null;
        $this->container['id'] = isset($data['id']) ? $data['id'] : null;
        $this->container['bsp'] = isset($data['bsp']) ? $data['bsp'] : null;
        $this->container['status'] = isset($data['status']) ? $data['status'] : null;
        $this->container['sr'] = isset($data['sr']) ? $data['sr'] : null;
    }

    /**
     * show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalid_properties = array();
        $allowed_values = array("B", "L");
        if (!in_array($this->container['side'], $allowed_values)) {
            $invalid_properties[] = "invalid value for 'side', must be one of #{allowed_values}.";
        }

        $allowed_values = array("L", "P", "MOC");
        if (!in_array($this->container['pt'], $allowed_values)) {
            $invalid_properties[] = "invalid value for 'pt', must be one of #{allowed_values}.";
        }

        $allowed_values = array("L", "LOC", "MOC");
        if (!in_array($this->container['ot'], $allowed_values)) {
            $invalid_properties[] = "invalid value for 'ot', must be one of #{allowed_values}.";
        }

        $allowed_values = array("E", "EC");
        if (!in_array($this->container['status'], $allowed_values)) {
            $invalid_properties[] = "invalid value for 'status', must be one of #{allowed_values}.";
        }

        return $invalid_properties;
    }

    /**
     * validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properteis are valid
     */
    public function valid()
    {
        $allowed_values = array("B", "L");
        if (!in_array($this->container['side'], $allowed_values)) {
            return false;
        }
        $allowed_values = array("L", "P", "MOC");
        if (!in_array($this->container['pt'], $allowed_values)) {
            return false;
        }
        $allowed_values = array("L", "LOC", "MOC");
        if (!in_array($this->container['ot'], $allowed_values)) {
            return false;
        }
        $allowed_values = array("E", "EC");
        if (!in_array($this->container['status'], $allowed_values)) {
            return false;
        }
        return true;
    }


    /**
     * Gets side
     * @return string
     */
    public function getSide()
    {
        return $this->container['side'];
    }

    /**
     * Sets side
     * @param string $side Side - the side of the order
     * @return $this
     */
    public function setSide($side)
    {
        $allowed_values = array('B', 'L');
        if (!in_array($side, $allowed_values)) {
            throw new \InvalidArgumentException("Invalid value for 'side', must be one of 'B', 'L'");
        }
        $this->container['side'] = $side;

        return $this;
    }

    /**
     * Gets sv
     * @return double
     */
    public function getSv()
    {
        return $this->container['sv'];
    }

    /**
     * Sets sv
     * @param double $sv Size Voided - the amount of the order that has been voided
     * @return $this
     */
    public function setSv($sv)
    {
        $this->container['sv'] = $sv;

        return $this;
    }

    /**
     * Gets pt
     * @return string
     */
    public function getPt()
    {
        return $this->container['pt'];
    }

    /**
     * Sets pt
     * @param string $pt Persistence Type - whether the order will persist at in play or not (L = LAPSE, P = PERSIST, MOC = Market On Close)
     * @return $this
     */
    public function setPt($pt)
    {
        $allowed_values = array('L', 'P', 'MOC');
        if (!in_array($pt, $allowed_values)) {
            throw new \InvalidArgumentException("Invalid value for 'pt', must be one of 'L', 'P', 'MOC'");
        }
        $this->container['pt'] = $pt;

        return $this;
    }

    /**
     * Gets ot
     * @return string
     */
    public function getOt()
    {
        return $this->container['ot'];
    }

    /**
     * Sets ot
     * @param string $ot Order Type - the type of the order (L = LIMIT, MOC = MARKET_ON_CLOSE, LOC = LIMIT_ON_CLOSE)
     * @return $this
     */
    public function setOt($ot)
    {
        $allowed_values = array('L', 'LOC', 'MOC');
        if (!in_array($ot, $allowed_values)) {
            throw new \InvalidArgumentException("Invalid value for 'ot', must be one of 'L', 'LOC', 'MOC'");
        }
        $this->container['ot'] = $ot;

        return $this;
    }

    /**
     * Gets p
     * @return double
     */
    public function getP()
    {
        return $this->container['p'];
    }

    /**
     * Sets p
     * @param double $p Price - the original placed price of the order
     * @return $this
     */
    public function setP($p)
    {
        $this->container['p'] = $p;

        return $this;
    }

    /**
     * Gets sc
     * @return double
     */
    public function getSc()
    {
        return $this->container['sc'];
    }

    /**
     * Sets sc
     * @param double $sc Size Cancelled - the amount of the order that has been cancelled
     * @return $this
     */
    public function setSc($sc)
    {
        $this->container['sc'] = $sc;

        return $this;
    }

    /**
     * Gets rc
     * @return string
     */
    public function getRc()
    {
        return $this->container['rc'];
    }

    /**
     * Sets rc
     * @param string $rc Regulator Code - the regulator of the order
     * @return $this
     */
    public function setRc($rc)
    {
        $this->container['rc'] = $rc;

        return $this;
    }

    /**
     * Gets s
     * @return double
     */
    public function getS()
    {
        return $this->container['s'];
    }

    /**
     * Sets s
     * @param double $s Size - the original placed size of the order
     * @return $this
     */
    public function setS($s)
    {
        $this->container['s'] = $s;

        return $this;
    }

    /**
     * Gets pd
     * @return int
     */
    public function getPd()
    {
        return $this->container['pd'];
    }

    /**
     * Sets pd
     * @param int $pd Placed Date - the date the order was placed
     * @return $this
     */
    public function setPd($pd)
    {
        $this->container['pd'] = $pd;

        return $this;
    }

    /**
     * Gets rac
     * @return string
     */
    public function getRac()
    {
        return $this->container['rac'];
    }

    /**
     * Sets rac
     * @param string $rac Regulator Auth Code - the auth code returned by the regulator
     * @return $this
     */
    public function setRac($rac)
    {
        $this->container['rac'] = $rac;

        return $this;
    }

    /**
     * Gets md
     * @return int
     */
    public function getMd()
    {
        return $this->container['md'];
    }

    /**
     * Sets md
     * @param int $md Matched Date - the date the order was matched (null if the order is not matched)
     * @return $this
     */
    public function setMd($md)
    {
        $this->container['md'] = $md;

        return $this;
    }

    /**
     * Gets sl
     * @return double
     */
    public function getSl()
    {
        return $this->container['sl'];
    }

    /**
     * Sets sl
     * @param double $sl Size Lapsed - the amount of the order that has been lapsed
     * @return $this
     */
    public function setSl($sl)
    {
        $this->container['sl'] = $sl;

        return $this;
    }

    /**
     * Gets avp
     * @return double
     */
    public function getAvp()
    {
        return $this->container['avp'];
    }

    /**
     * Sets avp
     * @param double $avp Average Price Matched - the average price the order was matched at (null if the order is not matched
     * @return $this
     */
    public function setAvp($avp)
    {
        $this->container['avp'] = $avp;

        return $this;
    }

    /**
     * Gets sm
     * @return double
     */
    public function getSm()
    {
        return $this->container['sm'];
    }

    /**
     * Sets sm
     * @param double $sm Size Matched - the amount of the order that has been matched
     * @return $this
     */
    public function setSm($sm)
    {
        $this->container['sm'] = $sm;

        return $this;
    }

    /**
     * Gets id
     * @return string
     */
    public function getId()
    {
        return $this->container['id'];
    }

    /**
     * Sets id
     * @param string $id Bet Id - the id of the order
     * @return $this
     */
    public function setId($id)
    {
        $this->container['id'] = $id;

        return $this;
    }

    /**
     * Gets bsp
     * @return double
     */
    public function getBsp()
    {
        return $this->container['bsp'];
    }

    /**
     * Sets bsp
     * @param double $bsp BSP Liability - the BSP liability of the order (null if the order is not a BSP order)
     * @return $this
     */
    public function setBsp($bsp)
    {
        $this->container['bsp'] = $bsp;

        return $this;
    }

    /**
     * Gets status
     * @return string
     */
    public function getStatus()
    {
        return $this->container['status'];
    }

    /**
     * Sets status
     * @param string $status Status - the status of the order (E = EXECUTABLE, EC = EXECUTION_COMPLETE)
     * @return $this
     */
    public function setStatus($status)
    {
        $allowed_values = array('E', 'EC');
        if (!in_array($status, $allowed_values)) {
            throw new \InvalidArgumentException("Invalid value for 'status', must be one of 'E', 'EC'");
        }
        $this->container['status'] = $status;

        return $this;
    }

    /**
     * Gets sr
     * @return double
     */
    public function getSr()
    {
        return $this->container['sr'];
    }

    /**
     * Sets sr
     * @param double $sr Size Remaining - the amount of the order that is remaining unmatched
     * @return $this
     */
    public function setSr($sr)
    {
        $this->container['sr'] = $sr;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     * @param  integer $offset Offset
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     * @param  integer $offset Offset
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     * @param  integer $offset Offset
     * @param  mixed   $value  Value to be set
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     * @param  integer $offset Offset
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(\Swagger\Client\ObjectSerializer::sanitizeForSerialization($this), JSON_PRETTY_PRINT);
        }

        return json_encode(\Swagger\Client\ObjectSerializer::sanitizeForSerialization($this));
    }
}


